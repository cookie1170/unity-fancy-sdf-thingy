#pragma kernel CSMain

/*
*----------------------------
 * DECLARATION
 * ---------------------------
 */

struct Circle
{
    float4 Color;
    float2 Position;
    float Radius;
    float BlendingFactor;
};

struct Box
{
    float4 Color;
    float2 Position;
    float2 Dimensions;
    float BlendingFactor;
};

struct SDFInfo
{
    float minDist;
    float avgBlendingFactor;
    float4 minColor;
};

RWTexture2D<float4> screenTexture;
StructuredBuffer<Circle> circleBuffer;
StructuredBuffer<Box> boxBuffer;
float2 resolution;

/*
 *----------------------------
 * MATH FUNCTIONS
 * ---------------------------
 */

float2 smoothMin(float a, float b, float k)
{
    float h = 1.0 - min(abs(a - b) / (4.0 * k), 1.0);
    float w = h * h;
    float m = w * 0.5;
    float s = w * k;
    return a < b ? float2(a-s,m) : float2(b-s,1.0-m);
}

float sdCircle(float2 p, Circle circle)
{
    p -= circle.Position;
    return length(p) - circle.Radius;
}

float sdBox(float2 position, Box box)
{
    position -= box.Position;
    float2 d = abs(position) - box.Dimensions;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

/*
 *----------------------------
 * COMPUTATION
 * ---------------------------
 */

SDFInfo ComputeShape(float dist, float blendingFactor, float4 color, SDFInfo info)
{
    SDFInfo result;
    float2 sminResult = smoothMin(dist, info.minDist, max(info.avgBlendingFactor, blendingFactor));
    result.minDist = sminResult.x;
    result.avgBlendingFactor = lerp(info.avgBlendingFactor, blendingFactor, 1.0 - sminResult.y);
    result.minColor = lerp(info.minColor, color, 1.0 - sminResult.y);
    return result;
}

float SDF(float2 pos, out float4 color)
{
    SDFInfo info;
    info.minDist = 99999999;
    info.avgBlendingFactor = 0.0;
    info.minColor = 0;
    uint countCircle;
    uint countBox;
    uint stride;
    circleBuffer.GetDimensions(countCircle, stride);
    boxBuffer.GetDimensions(countBox, stride);
    for (uint i = 0; i < countCircle; ++i) {
        Circle shape = circleBuffer[i]; float dist = sdCircle(pos, shape);
        info = ComputeShape(dist, shape.BlendingFactor, shape.Color, info);
    }
    for (uint i = 0; i < countBox; ++i) {
        Box shape = boxBuffer[i]; float dist = sdBox(pos, shape);
        info = ComputeShape(dist, shape.BlendingFactor, shape.Color, info);
    }
    color = info.minColor;
    return info.minDist;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float4 color;
    float dist = SDF(id.xy, color);
    if (dist <= 0)
        screenTexture[id.xy] = float4(lerp(color.rgb, screenTexture[id.xy].rgb, 1.0 - color.a), 1);
    else if (dist <= 8)
        screenTexture[id.xy] = 1;
}
